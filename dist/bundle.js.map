{"version":3,"sources":["webpack:///webpack/bootstrap ad44111ae150507c21ae","webpack:///./src/constants.js","webpack:///./src/universe.js","webpack:///./src/cell.js","webpack:///./src/index.js","webpack:///./src/painter.js","webpack:///./src/interface.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AClBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA,sCAAsC,6CAA6C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,sBAAsB,qBAAqB;AAC3C,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACnMA;;AAEA,OAAO,YAAY;;AAEnB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;;AClGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wCAAwC;;AAE3D;;AAEA;;AAEA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;;AAEA,sBAAsB,qBAAqB;AAC3C,wBAAwB,oBAAoB;AAC5C,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC7KA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qIAAqI;AACrI;AACA;;AAEA;AACA,mIAAmI;AACnI;AACA;;AAEA;AACA,kIAAkI;AAClI;AACA;;AAEA;AACA,oJAAoJ;AACpJ;AACA;;AAEA;AACA,oIAAoI;AACpI;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ad44111ae150507c21ae","const CONSTANTS = {\n  HEX_IN_ANGLE: (Math.PI * 2) / 6,\n  HEX_START_ANGLE: (Math.PI / 6),\n  TWO_PI: Math.PI * 2,\n  RUN: 'RUN',\n  RING: 'RING',\n  DEFAULT: 'DEFAULT',\n  INSPECT: 'INSPECT',\n  NEIGHBORS: [\n    [0, -1],\n    [1, -1],\n    [1, 0],\n    [0, 1],\n    [-1, 1],\n    [-1, 0]\n  ]\n};\n\nexport default CONSTANTS;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants.js\n// module id = 0\n// module chunks = 0","import Cell from './cell';\nimport Painter from './painter';\n\nclass Universe {\n  constructor(width, height, cellSize, sketch, seed)  {\n    this.width = width;\n    this.height = height;\n    this.cellSize = cellSize;\n    this.gridWidth = Math.floor((width / cellSize) * 0.68);\n    this.gridHeight = Math.floor((height / cellSize) * 0.7);\n    this.painter = new Painter(this, sketch);\n\n    this.cellsToUpdate = [];\n    this.cellsToUpdateTemp = [];\n    this.cellsToRender = [];\n    this.cellsToRenderTemp = [];\n    this.grid = [];\n    this.tempGrid = [];\n    this.generateGrid(seed);\n\n    // this.grid = this.generateGrid(seed);\n    // this.tempGrid = this.generateGrid(seed);\n  }\n\n  generateGrid(seed) {\n    let q;\n    let r;\n    let qStart = 1;\n    let rStart = 0;\n    this.grid = [];\n    this.tempGrid = [];\n    let tempRow = [];\n\n    for (let i = 0; i < this.gridHeight; i++) {\n      if (i % 2 === 0) {\n        qStart --;\n      }\n      q = qStart;\n      if (i % 2 !== 0) {\n        rStart --;\n      }\n      r = rStart;\n\n      for (let j = 0; j < this.gridWidth; j++) {\n        const s = (-q - r);\n        let inputSeed = seed;\n        if (inputSeed === undefined) { inputSeed = Math.floor((Math.random() * 3)); }\n        const cell = new Cell(q, r, s, this, inputSeed);\n        if (inputSeed === 1 || inputSeed === 2) {\n          this.cellsToRender.push([q, s]);\n          this.cellsToUpdate.push([q, s]);\n          this.cellsToUpdate.concat(cell.neighborCoords);\n        }\n        tempRow.push(cell);\n        q++;\n        r--;\n      };\n      this.grid.push(tempRow);\n      this.tempGrid.push(tempRow);\n      tempRow = [];\n    };\n    // return grid;\n  }\n\n  clearGrid() {\n    this.generateGrid(0);\n  }\n\n  resetGridRandom() {\n    this.generateGrid();\n  }\n\n  // converts a rectangular pixel coordinate to an axial coordinate\n  pixelToHex(x, y) {\n    const q = (x * (Math.sqrt(3) / 3) - (y / 3)) / this.cellSize;\n    const s = (y * (2 / 3)) / this.cellSize;\n    return this.roundHex(q, s);\n  }\n\n  // pixel coordinates can be floats and can yield non-integer axial coordinates\n  // this function rounds non-integer axial coordinates\n  roundHex(q, s) {\n    let r = -q - s\n    let rQ = Math.round(q);\n    let rR = Math.round(r);\n    let rS = Math.round(s);\n    const qDiff = Math.abs(rQ - q);\n    const rDiff = Math.abs(rR - r);\n    const sDiff = Math.abs(rS - s);\n\n    if (qDiff > rDiff && qDiff > sDiff) {\n      rQ = -rR - rS;\n    } else if (rDiff > sDiff) {\n      rR = -rQ - rS;\n    } else {\n      rS = -rQ - rR;\n    }\n    return { q: rQ, s: rS };\n  }\n\n  // returns cell at a given axial coordinate\n  getCell(q, s) {\n    const row = this.grid[s];\n    if (!row) {\n      return null;\n    } else {\n      return row[q + Math.floor(s / 2)];\n    }\n  }\n\n  getCellGridCoord(q, s) {\n    const rowIdx = s;\n    const colIdx = q + Math.floor(s / 2);\n    return { row: rowIdx, col: colIdx};\n  }\n\n  // returns cell at a given pixel coordinate\n  getCellPixel(x, y) {\n    const hexCoord = this.pixelToHex(x, y);\n    return this.getCell(hexCoord.q, hexCoord.s);\n  }\n\n  setCell(x, y, state) {\n    const hexCoord = this.pixelToHex(x, y);\n    const cell = this.getCell(hexCoord.q, hexCoord.s);\n    cell.state = state;\n    return cell;\n  }\n\n  updateCellStates() {\n    for (let i = 0; i < this.cellsToUpdate.length; i++) {\n      const updateCoord = this.cellsToUpdate[i];\n      const gridCoord = this.getCellGridCoord(updateCoord[0], updateCoord[1]);\n      const row = gridCoord.row;\n      const col = gridCoord.col;\n      const updateCell = this.grid[row][col];\n      let newState\n      if (row < 1 ||\n          row > (this.gridHeight - 2) ||\n          col < 1 ||\n          col > (this.gridWidth - 2)\n          ) {\n          newState = 0;\n        } else {\n          newState = updateCell.newState();\n\n        }\n      this.tempGrid[row][col].state = newState;\n      if (newState === 1 || newState === 2) {\n        this.cellsToUpdateTemp.push(updateCoord);\n        this.cellsToUpdateTemp.concat(updateCell.neighborCoords);\n        this.cellsToRenderTemp.push(updateCoord);\n      }\n    }\n    this.cellsToUpdate = this.cellsToUpdateTemp;\n    this.cellsToRender = this.cellsToRenderTemp;\n    this.cellsToUpdateTemp = [];\n    this.cellsToRenderTemp = [];\n    this.grid = this.tempGrid;\n\n\n    // for (let i = 0; i < this.gridHeight; i++) {\n    //   for (let j = 0; j < this.gridWidth; j++) {\n    //     if (i < 1 ||\n    //         i > (this.gridHeight - 2) ||\n    //         j < 1 ||\n    //         j > (this.gridWidth - 2)\n    //         ) {\n    //           this.tempGrid[i][j].state = 0;\n    //         } else {\n    //           this.tempGrid[i][j].state = this.grid[i][j].newState();\n    //         }\n    //   };\n    // };\n    // this.grid = this.tempGrid;\n  }\n\n  logActiveCells() {\n    const activeCellCoords = [];\n    for (let i = 0; i < this.gridHeight; i++) {\n      for (let j = 0; j < this.gridWidth; j++) {\n        const cell = this.grid[i][j];\n        if (cell.state > 0) {\n          activeCellCoords.push(cell.coord);\n        }\n      };\n    };\n    console.log(activeCellCoords);\n  }\n\n  render() {\n    this.painter.render();\n  }\n}\n\nexport default Universe;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/universe.js\n// module id = 1\n// module chunks = 0","import CONSTANTS from './constants';\n\nconst { NEIGHBORS } = CONSTANTS;\n\nclass Cell {\n  constructor(q, r, s, universe, state) {\n    this.coord = { q, r, s };\n    this.state = state;\n    this.universe = universe;\n    this.pixelCoord = this.hexToPixel(q, s, universe.cellSize);\n    this.neighborCoords = this.getNeighborCoords(q, s);\n  }\n\n  // converts axial coordinate to pixel coordinate\n  hexToPixel(q, s, size) {\n    const x = (Math.sqrt(3) * q + Math.sqrt(3) / 2 * s) * size;\n    const y = (3 / 2) * s * size;\n    const pixelCoord = { x: x, y: y };\n    return pixelCoord;\n  }\n\n  getState(q, s) {\n    const cell = this.universe.getCell(q, s);\n    return cell.state;\n  }\n\n  getHeadcount() {\n    const headcount = this.neighborCoords.reduce((accum, coord) => {\n      return accum + this.getState(coord[0], coord[1]);\n    }, 0);\n    return headcount;\n  }\n\n  newState() {\n    const heads = this.getHeadcount();\n    let newState;\n    switch(this.state) {\n      case 0:\n        if (heads === 4) {\n          newState = 1;} else {\n            newState = 0;\n          }\n        break;\n      case 1:\n        switch(heads) {\n          case 1:\n            newState = 2;\n            break;\n          case 2:\n            newState = 2;\n            break;\n          case 3:\n            newState = 2;\n            break;\n          case 4:\n            newState = 2;\n            break;\n          case 6:\n            newState = 2;\n            break;\n          default:\n            newState = 0;\n            break;\n          };\n        break;\n      case 2:\n        switch(heads) {\n          case 1:\n            newState = 2;\n            break;\n          case 2:\n            newState = 1;\n            break;\n          case 3:\n            newState = 0;\n            break;\n          case 4:\n            newState = 1;\n            break;\n          default:\n            newState = 0;\n            break;\n        };\n        break;\n    };\n    return newState;\n  }\n\n  getNeighborCoords(q, s) {\n    const neighbors = [];\n    NEIGHBORS.forEach(delta => {\n      const coord = [q + delta[0], s + delta[1]];\n      neighbors.push(coord);\n    });\n    return neighbors;\n  }\n}\n\nexport default Cell;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/cell.js\n// module id = 2\n// module chunks = 0","import Universe from './universe';\nimport CONSTANTS from './constants';\nimport Interface from './interface';\n\nconst {\n        RUN,\n        RING,\n        DEFAULT,\n        INSPECT\n      } = CONSTANTS;\n\nconst p5Canvas = function( sketch ) {\n  let width = sketch.windowWidth +50;\n  let height = sketch.windowHeight + 50;\n  let cellSize = 10;\n\n  let uni = new Universe(width, height, cellSize, sketch);\n  let ui = new Interface(sketch, uni);\n\n  sketch.setup = function() {\n    let canvas = sketch.createCanvas(width, height);\n    canvas.position(-50, -50);\n    sketch.cursor(sketch.CROSS);\n    ui.interfaceSetup('ui-controls');\n  };\n\n  sketch.draw = function() {\n    sketch.frameRate(ui.slider.value());\n    sketch.background('black');\n    uni.render();\n    uni.painter.renderCursor();\n    fpsCounter();\n  };\n\n  sketch.windowResized = function() {\n    width = sketch.windowWidth +50;\n    height = sketch.windowHeight + 50;\n    sketch.resizeCanvas(width, height);\n    uni = new Universe(width, height, cellSize, sketch);\n    ui.universe = uni;\n    ui.painter = uni.painter;\n  }\n\n  const fpsCounter = function() {\n    sketch.push();\n    sketch.fill(255);\n    sketch.stroke(0);\n    var fps = sketch.frameRate();\n    sketch.text(\"FPS: \" + fps.toFixed(2), sketch.width - 80, sketch.height - 85);\n    sketch.pop();\n  };\n\n  sketch.touchStarted = function() {\n    uni.painter.paintCell(\n      sketch.mouseX,\n      sketch.mouseY\n      );\n    return false;\n  };\n\n  sketch.touchEnded = function() {\n    return false;\n  };\n\n  sketch.touchMoved = function() {\n    switch(uni.painter.brush) {\n      case RING:\n        uni.painter.setBrush();\n        break;\n      default:\n        uni.painter.paintCell(\n          sketch.mouseX,\n          sketch.mouseY\n          );\n        if (uni.painter.mode === RUN) {\n        uni.painter.paintCell(\n          sketch.pmouseX,\n          sketch.pmouseY\n          );\n        }\n        break;\n    };\n    return false;\n  };\n\n  sketch.mousePressed = function() {\n    switch(uni.painter.mode) {\n      case INSPECT:\n        console.log(\n          uni.getCellPixel(sketch.mouseX, sketch.mouseY)\n        );\n        break;\n      default:\n        switch(uni.painter.brush) {\n          case RING:\n          uni.painter.setBrush();\n          break;\n          default:\n          uni.painter.paintCell(\n            sketch.mouseX,\n            sketch.mouseY\n          );\n          break;\n        };\n        break;\n    }\n  };\n  sketch.mouseReleased = function() {\n  };\n\n  sketch.mouseDragged = function() {\n    switch(uni.painter.brush) {\n      case RING:\n        uni.painter.setBrush();\n        break;\n      default:\n        uni.painter.paintCell(\n          sketch.mouseX,\n          sketch.mouseY\n          );\n          if (uni.painter.mode === RUN) {\n          uni.painter.paintCell(\n            sketch.pmouseX,\n            sketch.pmouseY\n            );\n          }\n        break;\n    };\n  }\n\n  sketch.deviceShaken = function() {\n    if (uni.painter.mode === RUN) {\n      uni.painter.mode = null;\n      uni.clearGrid();\n    } else {\n      uni.painter.mode = RUN;\n    }\n    return false;\n  };\n\n  sketch.keyPressed = function() {\n    switch(sketch.keyCode) {\n      case 32:\n        if (uni.painter.mode === RUN) {\n          uni.painter.mode = null;\n        } else if (uni.painter.mode === null) {\n          uni.painter.mode = RUN;\n        }\n        break;\n      case sketch.BACKSPACE:\n        uni.clearGrid();\n        break;\n      case sketch.ENTER:\n        uni.resetGridRandom();\n        sketch.redraw();\n        break;\n    };\n  };\n};\n\nvar myp5 = new p5(p5Canvas, 'sketch');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 3\n// module chunks = 0","import Universe from './universe';\nimport Cell from './cell';\nimport CONSTANTS from './constants';\n\nconst {\n        HEX_IN_ANGLE,\n        HEX_START_ANGLE,\n        TWO_PI,\n        RUN,\n        RING,\n        DEFAULT,\n        INSPECT\n      } = CONSTANTS;\n\nclass Painter {\n  constructor(universe, sketch) {\n    this.universe = universe;\n    this.sketch = sketch;\n    this.cellSize = universe.cellSize;\n    this.gridWidth = universe.gridWidth;\n    this.gridHeight = universe.gridHeight;\n    this.cellsToRender = universe.cellsToRender;\n    this.mode = RUN;\n    this.brush = null;\n    this.eraser = 0;\n    this.mouseOver = null;\n    this.brushQueue = [];\n\n    this.cursors = {\n      RING: this.ringCursor.bind(this),\n      DEFAULT: this.hexCursor.bind(this),\n    }\n  }\n\n  plotCell(cell) {\n    this.sketch.push();\n    if (cell.state === 1) {\n      this.sketch.fill('#1CA5B8');\n    } else if (cell.state === 2) {\n      this.sketch.fill('#FF404C');\n    }\n    this.drawHex(cell.pixelCoord.x, cell.pixelCoord.y)\n    this.sketch.pop();\n  }\n\n  outOfBounds() {\n    return (this.sketch.mouseX < (this.cellSize * 2) ||\n        this.sketch.mouseY < (this.cellSize) ||\n        this.sketch.mouseX > (this.universe.width - this.cellSize) ||\n        this.sketch.mouseY > (this.universe.height - this.cellSize)) ||\n        (this.sketch.pmouseX < (this.cellSize * 2) ||\n            this.sketch.pmouseY < (this.cellSize) ||\n            this.sketch.pmouseX > (this.universe.width - this.cellSize) ||\n            this.sketch.pmouseY > (this.universe.height - this.cellSize))\n  }\n\n  renderCursor() {\n    this.brushQueue = [];\n\n    this.sketch.push();\n    let cursor = this.cursors[DEFAULT];\n\n    if (!this.mouseOver) {\n      this.sketch.strokeWeight(2);\n      this.sketch.stroke('blue');\n    }\n\n    if (!this.eraser) {\n      this.sketch.noFill();\n    } else {\n      this.sketch.fill('rgba(255, 255, 255, .9)');\n    }\n\n    if (this.brush) {\n      cursor = this.cursors[this.brush];\n    }\n    if (this.outOfBounds()) {\n      this.sketch.pop();\n      return;\n    }\n    cursor();\n    this.sketch.pop();\n  }\n\n  hexCursor() {\n    const pCell = this.universe.getCellPixel(this.sketch.pmouseX, this.sketch.pmouseY);\n    const cell = this.universe.getCellPixel(this.sketch.mouseX, this.sketch.mouseY);\n    this.drawHex(pCell.pixelCoord.x, pCell.pixelCoord.y);\n    this.drawHex(cell.pixelCoord.x, cell.pixelCoord.y);\n  }\n\n  ringCursor() {\n\n    const pCursorCell = this.universe.getCellPixel(this.sketch.pmouseX, this.sketch.pmouseY);\n    const pBrushCellCoords = pCursorCell.neighborCoords.map(coord => {\n      const cell = this.universe.getCell(coord[0], coord[1]);\n      this.brushQueue.push(cell);\n      this.drawHex(cell.pixelCoord.x, cell.pixelCoord.y);\n    })\n\n    const cursorCell = this.universe.getCellPixel(this.sketch.mouseX, this.sketch.mouseY);\n    const brushCellCoords = cursorCell.neighborCoords.map(coord => {\n      const cell = this.universe.getCell(coord[0], coord[1]);\n      this.brushQueue.push(cell);\n      this.drawHex(cell.pixelCoord.x, cell.pixelCoord.y);\n    })\n  }\n\n  setBrush() {\n    this.brushQueue.map(cell => {\n      this.paintCell(cell.pixelCoord.x, cell.pixelCoord.y);\n    });\n  }\n\n  drawHex(x, y) {\n    this.sketch.beginShape();\n    for (var a = HEX_START_ANGLE;\n                  a < TWO_PI;\n                  a += HEX_IN_ANGLE) {\n      var sx = x + Math.cos(a) * this.cellSize;\n      var sy = y + Math.sin(a) * this.cellSize;\n      this.sketch.vertex(sx, sy);\n    }\n    this.sketch.endShape(this.sketch.CLOSE);\n  }\n\n  renderGrid() {\n    for (let i = 0; i < this.universe.cellsToRender.length; i++) {\n\n      let cellCoord = this.universe.cellsToRender[i];\n\n      let cell = this.universe.getCell(cellCoord[0], cellCoord[1])\n\n      // if (!cell.state) { continue; }\n      this.sketch.push();\n      this.plotCell(cell)\n      this.sketch.pop();\n    }\n\n    // for (let i = 0; i < this.gridHeight; i++) {\n    //   for (let j = 0; j < this.gridWidth; j++) {\n    //     if (!this.universe.grid[i][j].state) { continue; }\n    //     this.sketch.push();\n    //     this.plotCell(this.universe.grid[i][j]);\n    //     this.sketch.pop();\n    //   };\n    // }\n  }\n\n  paintCell(x, y) {\n    let state;\n    this.eraser ? (state = 0) : (state = 1);\n\n    this.sketch.push();\n    this.sketch.fill('yellow');\n    this.universe.setCell(x, y, state);\n    this.drawHex(x,y);\n    this.sketch.pop();\n  }\n\n  render() {\n    switch(this.mode) {\n      case RUN:\n        this.universe.updateCellStates();\n        this.renderGrid();\n        break;\n      default:\n        this.renderGrid();\n        break;\n    }\n  }\n}\n\nexport default Painter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/painter.js\n// module id = 4\n// module chunks = 0","import CONSTANTS from './constants';\n\nconst {\n        RUN,\n        RING,\n        INSPECT\n      } = CONSTANTS;\n\nclass Interface {\n  constructor(sketch, universe) {\n    this.sketch = sketch;\n    this.universe = universe;\n    this.painter = universe.painter;\n\n    this.startToggle = this.startToggle.bind(this);\n    this.randomize = this.randomize.bind(this);\n    this.clear = this.clear.bind(this);\n    this.setHexBrush = this.setHexBrush.bind(this);\n    this.setRingBrush = this.setRingBrush.bind(this);\n    this.eraserToggle = this.eraserToggle.bind(this);\n    this.setInspectMode = this.setInspectMode.bind(this);\n    this.logActiveCells = this.logActiveCells.bind(this);\n    this.mouseOver = this.mouseOver.bind(this);\n    this.mouseOut = this.mouseOut.bind(this);\n  }\n\n  interfaceSetup(parentId) {\n    this.playButton(parentId);\n    this.clearButton(parentId);\n    this.randomizeButton(parentId);\n    this.hexBrushButton(parentId);\n    this.ringBrushButton(parentId);\n    this.eraserToggleButton(parentId);\n\n    this.slider = this.sketch.createSlider(1, 60, 60);\n    this.slider.parent('speed-slider');\n    this.slider.style('width', '140px');\n\n    // Developer Tools\n    // this.inspectModeButton(parentId);\n    // this.logActiveCellsButton(parentId);\n  }\n\n  pausePlay() {\n    if (this.painter.mode === RUN) {\n      return '<i class=\"material-icons\">pause</i>';\n    } else {\n      return '<i class=\"material-icons\">play_arrow</i>';\n    }\n  }\n\n  playButton(parentId) {\n    const playButton = this.sketch.createButton('<span class=\"button-contents\"><i class=\"material-icons\">pause</i><i class=\"material-icons\">play_arrow</i></span>');\n    playButton.mousePressed(this.startToggle).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  randomizeButton(parentId) {\n    const randomizeButton = this.sketch.createButton('<span class=\"button-contents\"><i class=\"material-icons\">shuffle</i><span>&nbsp;Randomize</span></span>');\n    randomizeButton.mousePressed(this.randomize).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  clearButton(parentId) {\n    const clearButton = this.sketch.createButton('<span class=\"button-contents\"><i class=\"material-icons\">backspace</i><span>&nbsp;Clear</span></span>');\n    clearButton.mousePressed(this.clear).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  hexBrushButton(parentId) {\n    const hexBrushButton = this.sketch.createButton('<span class=\"button-contents\"><i class=\"material-icons\">brush</i><span>&nbsp;Plain Brush</span></span>');\n    hexBrushButton.mousePressed(this.setHexBrush).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  ringBrushButton(parentId) {\n    const ringBrushButton = this.sketch.createButton('<span class=\"button-contents\"><i class=\"material-icons\">radio_button_unchecked</i><span>&nbsp;Ring Brush</span></span>');\n    ringBrushButton.mousePressed(this.setRingBrush).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  eraserToggleButton(parentId) {\n    const eraserToggleButton = this.sketch.createButton('<span class=\"button-contents\"><i class=\"material-icons\">tab</i><span>&nbsp;Eraser Mode</span></span>');\n    eraserToggleButton.mousePressed(this.eraserToggle).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  inspectModeButton(parentId) {\n    const inspectModeButton = this.sketch.createButton('Inspect Mode');\n    inspectModeButton.mousePressed(this.setInspectMode).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  logActiveCellsButton(parentId) {\n    const logActiveCellsButton = this.sketch.createButton('Log Active Cells');\n    logActiveCellsButton.mousePressed(this.logActiveCells).parent(parentId).mouseOver(this.mouseOver).mouseOut(this.mouseOut);\n  }\n\n  // Button Callbacks\n  startToggle() {\n    this.painter.mode === RUN ? (this.painter.mode = null) : (this.painter.mode = RUN);\n  }\n\n  randomize() {\n    this.universe.resetGridRandom();\n  }\n\n  clear() {\n    this.universe.clearGrid();\n  }\n\n  setHexBrush() {\n    this.painter.brush = null;\n  }\n\n  setRingBrush() {\n    this.painter.brush = RING;\n  }\n\n  eraserToggle() {\n    this.painter.eraser ? (this.painter.eraser = 0) : (this.painter.eraser = 1);\n  }\n\n  setInspectMode() {\n    this.painter.mode = INSPECT;\n    this.painter.brush = null;\n  }\n\n  logActiveCells() {\n    this.universe.logActiveCells();\n  }\n\n  mouseOver() {\n    this.painter.mouseOver = 1;\n  }\n\n  mouseOut() {\n    this.painter.mouseOver = 0;\n  }\n}\n\nexport default Interface;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/interface.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}