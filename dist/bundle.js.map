{"version":3,"sources":["webpack:///webpack/bootstrap b4db7edd06c00bf63726","webpack:///./src/index.js","webpack:///./src/universe.js","webpack:///./src/cell.js","webpack:///./src/constants.js","webpack:///./src/painter.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACpHA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACRA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,oBAAoB;AACzC,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b4db7edd06c00bf63726","import Universe from './universe';\nimport CONSTANTS from './constants';\n\nconst {\n        RUN,\n        PAINT\n      } = CONSTANTS;\n\nconst p5Canvas = function( sketch ) {\n  const width = sketch.windowWidth * 0.97;\n  const height = sketch.windowHeight * 0.96;\n  const cellSize = 8;\n  let seed;\n  // const seed = 0;\n\n  const uni = new Universe(width, height, cellSize, sketch);\n\n  sketch.setup = function() {\n    sketch.createCanvas(width, height);\n    sketch.cursor(sketch.CROSS);\n    // sketch.noCursor();\n\n  };\n\n  sketch.draw = function() {\n    sketch.background('black');\n    // uni.painter.hexCursor();\n    uni.render();\n    fpsCounter();\n\n  };\n\n  const fpsCounter = function() {\n    sketch.push();\n    sketch.fill(255);\n    sketch.stroke(0);\n    var fps = sketch.frameRate();\n    sketch.text(\"FPS: \" + fps.toFixed(2), 10, sketch.height - 10);\n    sketch.pop();\n  }\n\n  sketch.mousePressed = function() {\n  };\n\n  sketch.mouseClicked = function() {\n    if (uni.painter.mode === PAINT) {\n      uni.painter.paintCell(\n        sketch.mouseX,\n        sketch.mouseY,\n        1);\n    }\n  };\n\n  sketch.mouseReleased = function() {\n  };\n\n  sketch.mouseDragged = function() {\n    if (uni.painter.mode === PAINT) {\n      uni.painter.paintCell(\n        sketch.mouseX,\n        sketch.mouseY,\n        1);\n      uni.painter.paintCell(\n        sketch.pmouseX,\n        sketch.pmouseY,\n        1);\n    } else {\n      uni.setCell(\n        sketch.mouseX,\n        sketch.mouseY,\n        1);\n      uni.setCell(\n        sketch.pmouseX,\n        sketch.pmouseY,\n        1);\n    }\n  }\n\n  sketch.deviceShaken = function() {\n    if (uni.painter.mode === PAINT) {\n      uni.painter.mode = RUN;\n      uni.painter.paintQueue = [];\n    } else {\n      uni.clearGrid();\n      uni.painter.mode = PAINT;\n    }\n  }\n\n  sketch.keyPressed = function() {\n    switch(sketch.keyCode) {\n      case 32:\n        if (uni.painter.mode === RUN) {\n          uni.painter.mode = null;\n        } else if (uni.painter.mode === null) {\n          uni.painter.mode = RUN;\n        }\n        break;\n      case sketch.BACKSPACE:\n        uni.clearGrid();\n        break;\n      case sketch.ENTER:\n        uni.resetGridRandom();\n        sketch.redraw();\n        break;\n      case 80:\n        if (uni.painter.mode === PAINT) {\n          uni.painter.mode = RUN;\n          uni.painter.paintQueue = [];\n        } else {\n          uni.clearGrid();\n          uni.painter.mode = PAINT;\n        }\n    };\n  };\n};\n\nvar myp5 = new p5(p5Canvas, 'sketch');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","import Cell from './cell';\nimport Painter from './painter';\n\nclass Universe {\n  constructor(width, height, cellSize, sketch, seed)  {\n    this.width = width;\n    this.height = height;\n    this.cellSize = cellSize;\n    this.gridWidth = Math.floor((width / cellSize) * 0.68);\n    this.gridHeight = Math.floor((height / cellSize) * 0.7);\n    this.grid = this.generateGrid(seed);\n    this.tempGrid = this.generateGrid(seed);\n    this.painter = new Painter(this, sketch);\n  }\n  generateGrid(seed) {\n    let q;\n    let r;\n    let qStart = 1;\n    let rStart = 0;\n    let grid = [];\n    let tempRow = [];\n\n    for (let i = 0; i < this.gridHeight; i++) {\n      if (i % 2 === 0) {\n        qStart --;\n      }\n      q = qStart;\n      if (i % 2 !== 0) {\n        rStart --;\n      }\n      r = rStart;\n\n      for (let j = 0; j < this.gridWidth; j++) {\n        const s = (-q - r);\n        tempRow.push(new Cell(q, r, s, this, seed));\n        q++;\n        r--;\n      };\n      grid.push(tempRow);\n      tempRow = [];\n    };\n    return grid;\n  }\n\n  clearGrid() {\n    this.grid = this.generateGrid(0);\n  }\n\n  resetGridRandom() {\n    this.grid = this.generateGrid();\n  }\n\n  pixelToHex(x, y) {\n    const q = (x * (Math.sqrt(3) / 3) - (y / 3)) / this.cellSize;\n    const s = (y * (2 / 3)) / this.cellSize;\n    return this.roundHex(q, s);\n  }\n\n  roundHex(q, s) {\n    let r = -q - s\n    let rQ = Math.round(q);\n    let rR = Math.round(r);\n    let rS = Math.round(s);\n    const qDiff = Math.abs(rQ - q);\n    const rDiff = Math.abs(rR - r);\n    const sDiff = Math.abs(rS - s);\n\n    if (qDiff > rDiff && qDiff > sDiff) {\n      rQ = -rR - rS;\n    } else if (rDiff > sDiff) {\n      rR = -rQ - rS;\n    } else {\n      rS = -rQ - rR;\n    }\n    return { q: rQ, s: rS };\n  }\n\n  getCell(q, s) {\n    return this.grid[s][q + Math.floor(s / 2)];\n  }\n\n  setCell(x, y, status) {\n    const hexCoord = this.pixelToHex(x, y);\n    const cell = this.getCell(hexCoord.q, hexCoord.s);\n    cell.alive = status;\n    return cell;\n  }\n\n  generationCycle() {\n    for (let i = 0; i < this.gridHeight; i++) {\n      for (let j = 0; j < this.gridWidth; j++) {\n        if (i < 1 ||\n            i > (this.gridHeight - 2) ||\n            j < 1 ||\n            j > (this.gridWidth - 2)\n            ) {\n              this.tempGrid[i][j].alive = 0;\n            } else {\n              this.tempGrid[i][j].alive = this.grid[i][j].newStatus();\n            }\n      };\n    };\n    this.grid = this.tempGrid;\n  }\n\n  render() {\n    this.painter.render();\n  }\n\n}\n\nexport default Universe;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/universe.js\n// module id = 1\n// module chunks = 0","const NEIGHBORS = [\n  [0, -1],\n  [1, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 1],\n  [-1, 0]\n];\n\nclass Cell {\n  constructor(q, r, s, universe, alive = Math.floor((Math.random() * 3) )) {\n    this.coord = { q, r, s };\n    this.alive = alive;\n    this.universe = universe;\n    this.pixelCoord = this.hexToPixel(q, s, universe.cellSize);\n    this.neighborCoords = this.getNeighborCoords(q, s);\n  }\n\n  hexToPixel(q, s, size) {\n    const x = (Math.sqrt(3) * q + Math.sqrt(3) / 2 * s) * size;\n    const y = (3 / 2) * s * size;\n    const pixelCoord = { x: x, y: y };\n    return pixelCoord;\n  }\n\n  getStatus(q, s) {\n    const cell = this.universe.getCell(q, s);\n    return cell.alive;\n  }\n\n  getHeadcount() {\n    const headcount = this.neighborCoords.reduce((accum, coord) => {\n      return accum + this.getStatus(coord[0], coord[1]);\n    }, 0);\n    return headcount;\n  }\n\n  newStatus() {\n    const heads = this.getHeadcount();\n    let newStatus;\n    switch(this.alive) {\n      case 0:\n        if (heads === 4) {\n          newStatus = 1;} else {\n            newStatus = 0;\n          }\n        break;\n      case 1:\n        switch(heads) {\n          case 1:\n            newStatus = 2;\n            break;\n          case 2:\n            newStatus = 2;\n            break;\n          case 3:\n            newStatus = 2;\n            break;\n          case 4:\n            newStatus = 2;\n            break;\n          case 6:\n            newStatus = 2;\n            break;\n          default:\n            newStatus = 0;\n            break;\n          };\n        break;\n      case 2:\n        switch(heads) {\n          case 1:\n            newStatus = 2;\n            break;\n          case 2:\n            newStatus = 1;\n            break;\n          case 4:\n            newStatus = 1;\n            break;\n          default:\n            newStatus = 0;\n            break;\n        };\n        break;\n    };\n    // const updatedCell = new Cell(this.coord.q, this.coord.r, this.coord.s, this.universe, newStatus);\n    return newStatus;\n  }\n\n  getNeighborCoords(q, s) {\n    const neighbors = [];\n    NEIGHBORS.forEach(delta => {\n      const coord = [q + delta[0], s + delta[1]];\n      neighbors.push(coord);\n    });\n    return neighbors;\n  }\n}\n\nexport default Cell;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/cell.js\n// module id = 2\n// module chunks = 0","const CONSTANTS = {\n  HEX_IN_ANGLE: (Math.PI * 2) / 6,\n  HEX_START_ANGLE: (Math.PI / 6),\n  TWO_PI: Math.PI * 2,\n  RUN: 'RUN',\n  PAINT: 'PAINT'\n};\n\nexport default CONSTANTS;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants.js\n// module id = 3\n// module chunks = 0","import Universe from './universe';\nimport Cell from './cell';\nimport CONSTANTS from './constants';\n\nconst {\n        HEX_IN_ANGLE,\n        HEX_START_ANGLE,\n        TWO_PI,\n        RUN,\n        PAINT\n      } = CONSTANTS;\n\nclass Painter {\n  constructor(universe, sketch) {\n    this.universe = universe;\n    this.sketch = sketch;\n    this.cellSize = universe.cellSize;\n    this.gridWidth = universe.gridWidth;\n    this.gridHeight = universe.gridHeight;\n    this.mode = RUN;\n    this.paintQueue = [];\n  }\n\n  plotCell(cell) {\n    this.sketch.push();\n    if (cell.alive === 1) {\n      this.sketch.stroke('yellow');\n      // this.sketch.fill('blue');\n    } else if (cell.alive === 2) {\n      this.sketch.stroke('yellow');\n      // this.sketch.fill('orange');\n    }\n    this.drawHex(cell.pixelCoord.x, cell.pixelCoord.y)\n    this.sketch.pop();\n  }\n\n  hexCursor() {\n    this.sketch.push();\n    this.sketch.stroke('white');\n    this.drawHex(this.sketch.mouseX, this.sketch.mouseY);\n    this.sketch.pop();\n  }\n\n  drawHex(x, y) {\n    this.sketch.beginShape();\n    for (var a = HEX_START_ANGLE;\n                  a < TWO_PI;\n                  a += HEX_IN_ANGLE) {\n      var sx = x + Math.cos(a) * this.cellSize;\n      var sy = y + Math.sin(a) * this.cellSize;\n      this.sketch.vertex(sx, sy);\n    }\n    this.sketch.endShape(this.sketch.CLOSE);\n  }\n\n  renderGrid() {\n    for (let i = 0; i < this.gridHeight; i++) {\n      for (let j = 0; j < this.gridWidth; j++) {\n        if (!this.universe.grid[i][j].alive) { continue; }\n        this.sketch.push();\n        this.plotCell(this.universe.grid[i][j]);\n        this.sketch.pop();\n      };\n    }\n  }\n\n  paintCell(x, y, status) {\n    this.sketch.push();\n    this.sketch.stroke('yellow');\n    this.drawHex(x,y);\n    this.sketch.pop();\n    this.paintQueue.push(this.universe.setCell(x, y, status));\n  }\n\n  render() {\n    switch(this.mode) {\n      case RUN:\n        this.universe.generationCycle();\n        this.renderGrid();\n        break;\n      case PAINT:\n        this.paintQueue.map(cell => this.plotCell(cell));\n        break;\n      default:\n        this.renderGrid();\n        break;\n    }\n  }\n}\n\nexport default Painter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/painter.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}